[
["index.html", "Multivariate Stats 1 Lesson 2 1.1 Random Variables and Vectors 1.2 Variance and Corrected Variance 1.3 Exercises", " Multivariate Stats Tiago dos Santos 2018-10-24 1 Lesson 2 1.1 Random Variables and Vectors 1.1.1 Elements of probability A random variable \\(\\textbf{X}\\) is a function that takes an event space and return a value: \\[ X: \\Omega \\rightarrow {\\rm I\\!R}\\] The behavious of a random variable \\(X\\) can be described by both probability function and distribution function: Distribution Function: \\(F(x) = P(\\text{x} \\leq x) (x \\in {\\rm I\\!R}; 0 \\leq F(x) \\leq 1 ) \\text{F(x) is differentiable}\\) For discrete variables, Probability Mass Function: For continuous variables, Probability Density Function: 1.1.2 1.2 Variance and Corrected Variance 1.2.1 Variance \\[ S_{n}^2 = \\frac{1}{N}\\sum\\limits_{i=1}^{N}(X_{i} - \\overline{X})^2 \\] \\[ S_{n}^2 = \\frac{1}{N}\\sum\\limits_{i=1}^{N}(X_{i} - \\overline{X})(X_{i} - \\overline{X}) \\] 1.2.2 Corrected Variance \\[ S_{n-1}^2 = \\frac{1}{n}\\sum\\limits_{i=1}^{n-1}(X_{i} - \\overline{X})^2 \\] \\[ S_{n-1}^2 = \\frac{1}{n}\\sum\\limits_{i=1}^{n-1}(X_{i} - \\overline{X})(X_{i} - \\overline{X}) \\] 1.2.3 Covariance \\[Cov(x,y) = \\frac{1}{n-1}\\sum\\limits_{i=1}^{n}(x_{i} - \\overline{x})(y_{i} - \\overline{y}) \\] \\[Cov(x,y) = Cov(y,x) \\] 1.2.4 Pearson Correlation Coefficient \\[r_{xy} = \\frac{Cov(x,y)}{\\sqrt{S_{x}^2 \\times S_{y}^2}}\\] The domain of this coefficient is [-1, 1] \\[ \\Sigma = V^{\\frac{1}{2}} \\] 1.3 Exercises X = matrix(c(42,52,48,58,4,5,4,3),4) XMeans &lt;- apply(X, 2, mean) XVars &lt;- var(X) Xcor &lt;- cor(X) dados &lt;- as.data.frame(readxl::read_xlsx(file.path(datasetsDir,&quot;data1.xlsx&quot;))) aplpack::faces(HSAUR3::USairpollution[1:9,], print.info = F) meanVector &lt;- c(5,10) Sigma &lt;- matrix(c(9,16,16,64),2) Sigma.eigen &lt;- eigen(Sigma) The eigen values are 68.3158765, 4.6841235 TO obtain the ellipse containing 95% of the population, we must calculate \\[(x-\\mu)&#39; \\times \\Sigma^{-1} \\times (x-\\mu)&#39; &lt;= \\chi^2_{(2)0.95}\\] "],
["lesson-3.html", "2 Lesson 3", " 2 Lesson 3 dados2 &lt;- as.data.frame(readxl::read_xlsx(file.path(datasetsDir, &quot;data2.xlsx&quot;))) s &lt;- seq(min(dados2$imc),max(dados2$imc), length.out = length(dados2$imc)) hist( dados2$imc, probability = T, xlim=c(min(dados2$imc),max(dados2$imc)), main=NULL, xlab=NULL) lines(s,dnorm(s,mean(dados2$imc),sd(dados2$imc))) plot(density(dados2[,1]),ylim=c(0,0.3),main = &quot; &quot;,ylab = &quot;Densidade&quot;) lines(density(dados2[,1],bw = 0.3),col=&quot;red&quot;) lines(density(dados2[,1],bw = 0.1),col=&quot;blue&quot;) legend(&quot;topright&quot;,col=c(1,2,4),lty=1,legend = c(&quot;bw=default&quot;,&quot;bw=0.3&quot;,&quot;bw=0.1&quot;)) plot(density(dados2[,1]),ylim=c(0,0.3),main = &quot; &quot;,ylab = &quot;Densidade&quot;) lines(density(dados2[,1],kernel = &quot;rectangular&quot;),col=&quot;red&quot;) lines(density(dados2[,1],kernel = &quot;epanechnikov&quot;),col=&quot;blue&quot;) legend(&quot;topright&quot;,col=c(1,2,4),lty=1,legend = c(&quot;default&quot;,&quot;rectangular&quot;,&quot;epanechnikov&quot;)) dados1 &lt;- as.data.frame(readxl::read_xlsx(file.path(datasetsDir, &quot;data1.xlsx&quot;), col_names = F)) par(mfrow=c(3,2)) plots &lt;- apply(dados1,2,function(iVar){ s &lt;- seq(min(iVar),max(iVar), length.out = length(iVar)) hist( iVar, probability = T, xlim=c(min(iVar),max(iVar)), main=NULL, xlab=NULL) lines(s,dnorm(s,mean(iVar),sd(iVar)),col=&quot;red&quot;) lines(density(iVar,kernel = &quot;rectangular&quot;),col=&quot;blue&quot;) legend(&quot;topright&quot;,col=c(1,2,4),lty=1,legend = c(&quot;histogram&quot;,&quot;dnorm&quot;,&quot;gaussian&quot;)) }) par(mfrow=c(1,1)) 2.0.1 Estatísticas Ordinais 2.0.1.1 Minimum \\[ x_\\left(1\\right) = x_\\left(1n\\right) \\] 2.0.1.2 Maximum \\[ x_\\left(n\\right) = x_\\left(nn\\right) \\] 2.0.1.3 Inverso da função distribuição Gaussiana qnorm(0.975) ## [1] 1.959964 2.0.1.4 QQ Plot x &lt;- c(-1.00,-0.10,0.16,0.41,0.62,0.80,1.26,1.54,1.71,2.3) xdf &lt;- as.data.frame(x) names(xdf) &lt;- c(&quot;values&quot;) nLength &lt;- length(xdf$values) xdf$empProb &lt;- sapply(1:nLength,function(idx){ (idx-0.5)/nLength }) xdf$theoreticProb &lt;- sapply(xdf$empProb,function(quantile){ qnorm(quantile) }) knitr::kable(xdf) values empProb theoreticProb -1.00 0.05 -1.6448536 -0.10 0.15 -1.0364334 0.16 0.25 -0.6744898 0.41 0.35 -0.3853205 0.62 0.45 -0.1256613 0.80 0.55 0.1256613 1.26 0.65 0.3853205 1.54 0.75 0.6744898 1.71 0.85 1.0364334 2.30 0.95 1.6448536 plot(xdf$empProb , xdf$theoreticProb ) car::qqp(x,distribution=&quot;norm&quot;) ## [1] 1 10 defaultMar &lt;- c(5, 4, 4, 2) + 0.1 par(mfrow=c(3,2),mar=c(0,0,0,0)) plots &lt;- apply(dados1,2,function(iVar){ car::qqp(iVar,distribution=&quot;norm&quot;) }) par(mfrow=c(1,1),defaultMar) 2.0.2 Transforming to Distance (slide 21) x1 &lt;- c(126974,96933,86656,63438,55264,50976,39069,36156,35209,32416) x2 &lt;- c(4224,3835,3510,3758,3939,1809,2946, 359,2480,2413) X &lt;- matrix(c(x1,x2),10,2) mx &lt;- colMeans(X) S &lt;- var(x) d2 &lt;- c() distanceCsquare &lt;- function(){ el - mean } for(i in 1:nrow(X)){ d2[i] &lt;- (t(X[i,]) - colMeans(X))%*%solve(var(X))%*%(X[i,]-colMeans(X)) } ## o u é que tem distribuição beta ## quantis teoriocos qui-quadrado qi_chi &lt;- round(qchisq(xdf$empProb, ncol(X)),3) qi_chi ## [1] 0.103 0.325 0.575 0.862 1.196 1.597 2.100 2.773 3.794 5.991 xdf$theoreticProbQuiSq &lt;- qi_chi ## quantis teoricos de beta qi_beta &lt;- round(qbeta(xdf$empProb, shape1 = ncol(X)/2, shape2=(nrow(X)-ncol(X)-1)/2),3) qi_beta ## [1] 0.015 0.045 0.079 0.116 0.157 0.204 0.259 0.327 0.418 0.575 xdf$theoreticProbQuiSq &lt;- qi_beta ## aqui deveria ser u em vez de d2 par(mfrow=c(1,2)) plot(xdf$theoreticProbQuiSq, d2) car::qqp(d2,distribution=&quot;chisq&quot;,df=ncol(X)) ## [1] 8 1 hypothesisVal &lt;- c(11,3) X &lt;- matrix(c(6,10,8,9,6,3),3) Xmeans &lt;- colMeans(X) S &lt;- var(X) Sminus1 &lt;- solve(S) t(nrow(X)*(Xmeans - hypothesisVal))%*%Sminus1%*%(Xmeans - hypothesisVal) ## [,1] ## [1,] 7 "],
["studies-experiments.html", "3 Studies &amp; Experiments 3.1 Matrixes’ Span and Determinantes 3.2 EigenValues and EigenVectors 3.3 Spectral Decomposition", " 3 Studies &amp; Experiments Unfortunately, no one can be told what the Matrix is. You have to see it for yourself - Morpheys 3.1 Matrixes’ Span and Determinantes matrixA2d &lt;- matrix(c(1,0,0,1),2) matrixA2d ## [,1] [,2] ## [1,] 1 0 ## [2,] 0 1 drawMatrixWithDet(matrixA2d,dim(matrixA2d)[1]) ## Warning: package &#39;bindrcpp&#39; was built under R version 3.4.4 matrixB2d &lt;- matrix(c(1,3,0,1),2) matrixB2d ## [,1] [,2] ## [1,] 1 0 ## [2,] 3 1 drawMatrixWithDet(matrixB2d,dim(matrixB2d)[1]) matrixA &lt;- matrix(c(1,0,0,0,1,0,0,0,1),3) matrixA ## [,1] [,2] [,3] ## [1,] 1 0 0 ## [2,] 0 1 0 ## [3,] 0 0 1 drawMatrixWithDet(matrixA,dim(matrixA)[1]) ## Warning: &#39;mesh3d&#39; objects don&#39;t have these attributes: &#39;mode&#39;, &#39;line&#39; ## Valid attributes include: ## &#39;type&#39;, &#39;visible&#39;, &#39;showlegend&#39;, &#39;legendgroup&#39;, &#39;opacity&#39;, &#39;name&#39;, &#39;uid&#39;, &#39;ids&#39;, &#39;customdata&#39;, &#39;selectedpoints&#39;, &#39;hoverinfo&#39;, &#39;hoverlabel&#39;, &#39;stream&#39;, &#39;transforms&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;i&#39;, &#39;j&#39;, &#39;k&#39;, &#39;text&#39;, &#39;delaunayaxis&#39;, &#39;alphahull&#39;, &#39;intensity&#39;, &#39;color&#39;, &#39;vertexcolor&#39;, &#39;facecolor&#39;, &#39;cauto&#39;, &#39;cmin&#39;, &#39;cmax&#39;, &#39;colorscale&#39;, &#39;autocolorscale&#39;, &#39;reversescale&#39;, &#39;showscale&#39;, &#39;colorbar&#39;, &#39;flatshading&#39;, &#39;contour&#39;, &#39;lightposition&#39;, &#39;lighting&#39;, &#39;xcalendar&#39;, &#39;ycalendar&#39;, &#39;zcalendar&#39;, &#39;scene&#39;, &#39;idssrc&#39;, &#39;customdatasrc&#39;, &#39;hoverinfosrc&#39;, &#39;xsrc&#39;, &#39;ysrc&#39;, &#39;zsrc&#39;, &#39;isrc&#39;, &#39;jsrc&#39;, &#39;ksrc&#39;, &#39;textsrc&#39;, &#39;intensitysrc&#39;, &#39;vertexcolorsrc&#39;, &#39;facecolorsrc&#39;, &#39;key&#39;, &#39;set&#39;, &#39;frame&#39;, &#39;transforms&#39;, &#39;_isNestedKey&#39;, &#39;_isSimpleKey&#39;, &#39;_isGraticule&#39;, &#39;_bbox&#39; matrixB &lt;- matrix(c(1,2,3,2,2,1,3,2,4),3) matrixB ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 2 2 2 ## [3,] 3 1 4 drawMatrixWithDet(matrixB,dim(matrixB)[1]) ## Warning: &#39;mesh3d&#39; objects don&#39;t have these attributes: &#39;mode&#39;, &#39;line&#39; ## Valid attributes include: ## &#39;type&#39;, &#39;visible&#39;, &#39;showlegend&#39;, &#39;legendgroup&#39;, &#39;opacity&#39;, &#39;name&#39;, &#39;uid&#39;, &#39;ids&#39;, &#39;customdata&#39;, &#39;selectedpoints&#39;, &#39;hoverinfo&#39;, &#39;hoverlabel&#39;, &#39;stream&#39;, &#39;transforms&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;i&#39;, &#39;j&#39;, &#39;k&#39;, &#39;text&#39;, &#39;delaunayaxis&#39;, &#39;alphahull&#39;, &#39;intensity&#39;, &#39;color&#39;, &#39;vertexcolor&#39;, &#39;facecolor&#39;, &#39;cauto&#39;, &#39;cmin&#39;, &#39;cmax&#39;, &#39;colorscale&#39;, &#39;autocolorscale&#39;, &#39;reversescale&#39;, &#39;showscale&#39;, &#39;colorbar&#39;, &#39;flatshading&#39;, &#39;contour&#39;, &#39;lightposition&#39;, &#39;lighting&#39;, &#39;xcalendar&#39;, &#39;ycalendar&#39;, &#39;zcalendar&#39;, &#39;scene&#39;, &#39;idssrc&#39;, &#39;customdatasrc&#39;, &#39;hoverinfosrc&#39;, &#39;xsrc&#39;, &#39;ysrc&#39;, &#39;zsrc&#39;, &#39;isrc&#39;, &#39;jsrc&#39;, &#39;ksrc&#39;, &#39;textsrc&#39;, &#39;intensitysrc&#39;, &#39;vertexcolorsrc&#39;, &#39;facecolorsrc&#39;, &#39;key&#39;, &#39;set&#39;, &#39;frame&#39;, &#39;transforms&#39;, &#39;_isNestedKey&#39;, &#39;_isSimpleKey&#39;, &#39;_isGraticule&#39;, &#39;_bbox&#39; 3.1.1 More that 3D You have to let it all go, Neo. Fear, doubt, and disbelief. Free your mind Morpheus Well, you have to stuck to the formulas… This will make sense once you can bind the visual insights to the formula insights to under 3D. 3.2 EigenValues and EigenVectors 3.2.1 Eigen Values \\[ |S-lI| = 0 \\] Subtracting \\(lI\\) from \\(S\\) will create a matrix with determinant equals zero, meaning all of its vectors lay on a single line - all the vectors have the same span 3.2.2 Eigen Vectores \\[ Sx = lx \\] I want an \\(x\\) vector that, when rotated by \\(S\\), the result is the same than scaling \\(x\\) by \\(l\\). 3.3 Spectral Decomposition "],
["exercises-1.html", "4 Exercises", " 4 Exercises "],
["exercise.html", "5 Exercise 5.1 Exercise 1 - Linear Algebra 5.2 5.3 11 5.4 12 5.5 13 5.6 14 5.7 15 5.8 16 5.9 17 5.10 18 5.11 19", " 5 Exercise 5.1 Exercise 1 - Linear Algebra 5.1.1 Ex 1 A = matrix(c(4,7,2,5,3,8),2) B = matrix(c(3,6,-2,9,4,-5),2) \\[ A + B = \\] A+B ## [,1] [,2] [,3] ## [1,] 7 0 7 ## [2,] 13 14 3 \\[ A - B = \\] A-B ## [,1] [,2] [,3] ## [1,] 1 4 -1 ## [2,] 1 -4 13 \\[ A&#39; \\times A = \\] t(A)%*%A ## [,1] [,2] [,3] ## [1,] 65 43 68 ## [2,] 43 29 46 ## [3,] 68 46 73 \\[ A \\times A&#39; = \\] A%*%t(A) ## [,1] [,2] ## [1,] 29 62 ## [2,] 62 138 5.1.2 Ex 2 A = matrix(c(1,2,3,-1),2) B = matrix(c(2,1,0,5),2) \\[ A \\times B = \\] A %*% B ## [,1] [,2] ## [1,] 5 15 ## [2,] 3 -5 \\[ B \\times A = \\] B %*% A ## [,1] [,2] ## [1,] 2 6 ## [2,] 11 -2 \\[ det(A \\times B) = \\] det(A %*% B ) ## [1] -70 \\[ det(A) = \\] det(A) ## [1] -7 \\[ det(B) = \\] det(B) ## [1] 10 5.1.3 Ex 3 A = matrix(c(1,2,5,2,4,10,3,6,15),3) B = matrix(c(-1,-1,1,1,1,-1,-2,-2,2),3) C = matrix(c(1,1,2,2,2,2,4,4,4),3) \\[ A \\times B = 0 \\] A %*% B ## [,1] [,2] [,3] ## [1,] 0 0 0 ## [2,] 0 0 0 ## [3,] 0 0 0 A %*% B[,1] ## [,1] ## [1,] 0 ## [2,] 0 ## [3,] 0 \\[ tr(A)\\] psych::tr(A) ## [1] 20 \\[ tr(B)\\] psych::tr(B) ## [1] 2 It is important to notice that the matrix A is a matrix in which all of its vectors are linear dependent - aka they are all in the same span: drawMatrixWithDet(A, dim(A)[1]) ## Warning: &#39;mesh3d&#39; objects don&#39;t have these attributes: &#39;mode&#39;, &#39;line&#39; ## Valid attributes include: ## &#39;type&#39;, &#39;visible&#39;, &#39;showlegend&#39;, &#39;legendgroup&#39;, &#39;opacity&#39;, &#39;name&#39;, &#39;uid&#39;, &#39;ids&#39;, &#39;customdata&#39;, &#39;selectedpoints&#39;, &#39;hoverinfo&#39;, &#39;hoverlabel&#39;, &#39;stream&#39;, &#39;transforms&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;i&#39;, &#39;j&#39;, &#39;k&#39;, &#39;text&#39;, &#39;delaunayaxis&#39;, &#39;alphahull&#39;, &#39;intensity&#39;, &#39;color&#39;, &#39;vertexcolor&#39;, &#39;facecolor&#39;, &#39;cauto&#39;, &#39;cmin&#39;, &#39;cmax&#39;, &#39;colorscale&#39;, &#39;autocolorscale&#39;, &#39;reversescale&#39;, &#39;showscale&#39;, &#39;colorbar&#39;, &#39;flatshading&#39;, &#39;contour&#39;, &#39;lightposition&#39;, &#39;lighting&#39;, &#39;xcalendar&#39;, &#39;ycalendar&#39;, &#39;zcalendar&#39;, &#39;scene&#39;, &#39;idssrc&#39;, &#39;customdatasrc&#39;, &#39;hoverinfosrc&#39;, &#39;xsrc&#39;, &#39;ysrc&#39;, &#39;zsrc&#39;, &#39;isrc&#39;, &#39;jsrc&#39;, &#39;ksrc&#39;, &#39;textsrc&#39;, &#39;intensitysrc&#39;, &#39;vertexcolorsrc&#39;, &#39;facecolorsrc&#39;, &#39;key&#39;, &#39;set&#39;, &#39;frame&#39;, &#39;transforms&#39;, &#39;_isNestedKey&#39;, &#39;_isSimpleKey&#39;, &#39;_isGraticule&#39;, &#39;_bbox&#39; No, the graph is not wrong. All of the vectors are in the same span. And since they are linear dependent, the determinant is 0. \\[ det(A)\\] det(A) ## [1] 0 5.2 A &lt;- matrix(c(3,1,1,1,0,2,1,2,0),3) eigenObj &lt;- eigen(A) Lambda &lt;- eigenObj$values*diag(3) P &lt;- eigenObj$vectors Pline &lt;- t(P) A.spectralDecomp &lt;- P%*%(Lambda)%*%Pline A.spectralDecomp.2 &lt;- matrix(rep(0,9),3) for(i in 1:nrow(Lambda)){ A.spectralDecomp.2 = A.spectralDecomp.2 + eigenObj$values[i]*P[,i]%*%t(P[,i]) } 5.3 11 dados11 &lt;- as.data.frame(readxl::read_xlsx(file.path(datasetsDir,&quot;..&quot;,&quot;Exercicios&quot;,&quot;exe11.xlsx&quot;), col_names=F)) plot(x=dados11$X__1,y=dados11$X__2) plot(x=dados11$X__1,y=dados11$X__3) plot(x=dados11$X__2,y=dados11$X__3) xbars &lt;- colMeans(dados11) S &lt;- var(dados11) CorrMatrix &lt;- cor(dados11) 5.4 12 dados12 &lt;- as.data.frame(readxl::read_xlsx(file.path(datasetsDir,&quot;..&quot;,&quot;Exercicios&quot;,&quot;exe12.xlsx&quot;), col_names=F)) plot(x=dados12$X__1,y=dados12$X__2) plot(x=dados12$X__5,y=dados12$X__3) plot(x=dados12$X__2,y=dados12$X__3) xbars &lt;- colMeans(dados12) S &lt;- var(dados12) CorrMatrix &lt;- cor(dados12) 5.5 13 dados13 &lt;- as.data.frame(readxl::read_xlsx(file.path(datasetsDir,&quot;..&quot;,&quot;Exercicios&quot;,&quot;exe13.xlsx&quot;), col_names=F)) xs &lt;- c(1,2,3) ys &lt;- c(4,5) xsbar &lt;-colMeans(dados13[,xs]) ysbar &lt;-colMeans(dados13[,ys]) S &lt;- var(dados13) S11 &lt;- S[xs,xs] S12 &lt;- S[xs,ys] S21 &lt;- S[ys,xs] S22 &lt;- S[ys,ys] 5.6 14 dados13 &lt;- as.data.frame(readxl::read_xlsx(file.path(datasetsDir,&quot;..&quot;,&quot;Exercicios&quot;,&quot;exe13.xlsx&quot;), col_names=F)) cLinear &lt;- c(3,-2,4,-1,1) xbar &lt;- colMeans(dados13) S &lt;- var(dados13) R &lt;- cor(dados13) zmeans &lt;- t(cLinear)%*%xbar zS &lt;- cLinear%*%S%*%cLinear #z = 3x1 − 2x2 + 4x3 − x4 + x5 . C &lt;- matrix(c(1,2,-1,1,-3,-2,1,1,1,1,-2,-2,1,-1,3),3) z_M_means &lt;- C%*%xbar Sz &lt;- C%*%var(dados13)%*%t(C) D &lt;- sqrt(diag(Sz))*diag(3) Dinv &lt;- solve(D) Ry &lt;- Dinv%*%Sz%*%Dinv 5.7 15 dados13 &lt;- as.data.frame(readxl::read_xlsx(file.path(datasetsDir,&quot;..&quot;,&quot;Exercicios&quot;,&quot;exe13.xlsx&quot;), col_names=F)) cLinear &lt;- c(3,-2,4,-1,1) xbar &lt;- colMeans(dados13) S &lt;- var(dados13) R &lt;- cor(dados13) S.eigen &lt;- eigen(S) S.det &lt;- prod(S.eigen$values) S.tr &lt;- sum(S.eigen$values) R.det &lt;- det(R) 5.8 16 dados16 &lt;- as.data.frame(readxl::read_xlsx(file.path(datasetsDir,&quot;..&quot;,&quot;Exercicios&quot;,&quot;exe16.xlsx&quot;), col_names=F)) dados16.xbar &lt;- colMeans(dados16) dados16.S &lt;- var(dados16) dados16.R &lt;- cor(dados16) dados16.S.det &lt;- det(dados16.S) dados16.S.tr &lt;- sum(diag(dados16.S)) #z=x1+2x2+x3−3x4 a &lt;- c(1,2,1,-3) z &lt;- t(a*t(dados16)) #w=−2x1+3x2−x3+2x4 b &lt;- c(-2,3,-1,2) w &lt;- t(b*t(dados16)) zbar &lt;- a*dados16.xbar wbar &lt;- b*dados16.xbar z.variance &lt;- diag(a*dados16.S*a) w.variance &lt;- diag(b*dados16.S*b) corr_between_z_w &lt;- (a*dados16.S*b)/(sqrt(a*dados16.S*a)*sqrt(b*dados16.S*b)) 5.9 17 M &lt;- matrix(c(-1,2,5,3,4,2,-2,2,3),3) Ones &lt;- matrix(c(1,1,1,1,1,1,1,1,1),3) colMeans(M) -&gt; M.colMeans M - Ones*M.colMeans ## [,1] [,2] [,3] ## [1,] -3 1 -4 ## [2,] -1 1 -1 ## [3,] 4 1 2 Smatrixes &lt;- 1/(dim(M)[1]-1)*t(M)%*%(diag(dim(M)[1]) - (1/dim(M)[1])*Ones)%*%M det(Smatrixes) ## [1] 2.173262e-14 prod(eigen(Smatrixes)$values) ## [1] 7.226065e-15 sum(eigen(Smatrixes)$values) ## [1] 17 5.10 18 TODO Question: How do I calculate the S_uv? dados18 &lt;- as.data.frame(readxl::read_xlsx(file.path(datasetsDir,&quot;..&quot;,&quot;Exercicios&quot;,&quot;exe18.xlsx&quot;), col_names=F)) dados18.S &lt;- var(dados18) UC &lt;- matrix(c(1,1,1,-2,1,2,0,0,0,0,0,0),2) VC &lt;- matrix(c(0,0,0,0,0,0,0,0,0,3,-1,2,1,-2,-3,-2,1,1),3) U.S &lt;- UC%*%dados18.S%*%t(UC) V.S &lt;- VC%*%dados18.S%*%t(VC) 5.11 19 dados19 &lt;- as.data.frame(readxl::read_xlsx(file.path(datasetsDir,&quot;..&quot;,&quot;Exercicios&quot;,&quot;exe19.xlsx&quot;))) dados19.xbar &lt;- colMeans(dados19) getStats &lt;- function(data){ statsAlturas &lt;- summary(data) return( list( mean = statsAlturas[4], var = var(data), sd = sd(data), min = statsAlturas[1], max = statsAlturas[6], quartis = c(statsAlturas[2],statsAlturas[3],statsAlturas[5]) ) ) } Alturas &lt;- getStats(c(dados19$AlturasA,dados19$AlturasB)) Pesos &lt;- getStats(c(dados19$PesosA,dados19$PesosB)) plts &lt;- sapply(colnames(dados19),function(col){ hist(dados19[,col],breaks=20, main=paste0(&quot;Histogram of &quot;,col)) }) plts &lt;- sapply(colnames(dados19),function(col){ boxplot(dados19[,col],breaks=20, main=paste0(&quot;Histogram of &quot;,col)) }) 1+1 "]
]
